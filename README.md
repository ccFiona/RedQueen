# 堆和栈的笔记

## 内存泄漏
内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

## 内存溢出
内存溢出（out of memory）通俗理解就是内存不够，通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。

## 堆和栈的定义
- 堆栈空间分配
栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

- 堆栈缓存方式
栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

- 堆栈数据结构区别
堆（数据结构）：堆（也叫优先队列），是一棵完全二叉树，它的特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。
栈（数据结构）：一种先进后出的数据结构。

- 一个由C/C++编译的程序占用的内存分为以下几个部分
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数名，局部变量的名等。其操作方式类似于数据结构中的栈。
2、堆区（heap）— 由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
3、静态区（static）—全局变量和局部静态变量的存储是放在一块的。程序结束后由系统释放。
4、文字常量区—常量字符串就是放在这里的，程序结束后由系统释放 。
5、程序代码区— 存放函数体的二进制代码。

- 变量的存储方式
|存储描述|持续性|作用域|链接性|	如何声明|
|--------|------|------|------|---------|
|自动 |自动 | 代码块|无| 	在代码块中|
|寄存器|自动|	代码块|	无|在代码块中，使用关键字 register|
|静态，无链接性|静态|代码块|	无|在代码块中，使用关键字 static|
|静态，外部链接性|静态|文件|	外部|不在任何函数内|
|静态，内部链接性|	静态|	文件|	内部|不在任何函数内，使用关键字 static|

- 注意:链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函数而言都是外部的。如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用关键字extern声明它：

[https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032?fr=aladdin#3_2](https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032?fr=aladdin)

## 内核的定义
内核，是一个操作系统的核心。是基于硬件的第一层软件扩充，提供操作系统的最基本的功能，是操作系统工作的基础，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。

## 分页查询
当数据量过大时，可能会导致各种各样的问题发生，例如：服务器资源被耗尽，因数据传输量过大而使处理超时，等等。最终都会导致查询无法完成。
解决这个问题的一个策略就是“分页查询”，也就是说不要一次性查询所有的数据，每次只查询一“页“的数据。这样分批次地进行处理，可以呈现出很好的用户体验，对服务器资源的消耗也不大。
打一个比方，有很多很多人要过河，而只有一条船摆渡。若让所有人都上船，肯定会导致沉船（资源耗尽）；若换一条超大的船，除了换船要很高的成本外，上船下船也要耗费很长时间。
所以最好的解决方法是，根据船的容量，每次只上一部分人。等这一船人过河以后，再摆渡下一批人。

## 反向代理 
反向代理(Reverse Proxy)方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。

## 通常的代理服务器
通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。由于外部网络上的主机并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器,而不是针对Internet上多个客户机的请求访问某一个固定的服务器，因此普通的Web代理服务器不支持外部对内部网络的访问请求。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性

## C++

在类中，如果什么都没有，则类占用1个字节，一旦类中有其他的占用空间成员，则这1个字节就不在计算之内，如一个类只有一个int则占用4字节而不是5字节。
如果只有成员函数，则还是只占用1个字节，因为类函数不占用空间
虚函数因为存在一个虚函数表，需要4个字节，数据成员对象如果为指针则为4字节，注意有字节对齐，如果为13字节，则进位到16字节空间。

1 先找有没有virtual 有的话就要建立虚函数表，+4
2 static的成员变量属于类域，不算入对象中      +0
3 神马成员都没有的类，或者只有成员函数        +1
4 对齐法则，对大家都没有问题

1. const常量、引用，只能初始化，不能修改赋值，所以必须在初始化列表中初始化
2. 如果父类中没有默认构造方法，那么，在子类中的初始化列表中必须显式的调用基类的有参数构造，否则会编译不通过

链接：https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618
来源：牛客网

所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。
        因此，将析构函数设为私有，类对象就无法建立在栈上了。代码如下：
```
[cpp] view plaincopyprint?
class  A  
{  
public :  
    A(){}  
    void  destory(){ delete   this ;}  
private :  
    ~A(){}  
};  
```
试着使用A a;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。

malloc和new有什么区别？
1,malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
2,对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。 
3,因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
4,C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。

5、new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。

C++中static关键字作用有哪些？
1、隐藏：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.
2、static的第二个作用是保持变量内容的持久：存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，
说到底static还是用来隐藏的。虽然这种用法不常见
3、static的第三个作用是默认初始化为0（static变量）
4、C++中的作用
1）不能将静态成员函数定义为虚函数。   
2）静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）  
3）静态数据成员在<定义或说明>时前面加关键字static。  

int(*n)[10]; 是数组指针  sizeof(n)=4
int* n[10];  是指针数组  sizeof(n)=40  

链接：https://www.nowcoder.com/questionTerminal/c81af62359474148b5f88cdd97649d85
来源：牛客网

unsigned int a= 0x1234的32位完全表示是0x00001234，在大端（低地址存储高位）处理器上的存储方式为：
由低地址到高地址依次为（假设低地址为0x4000）：
0x4000        0x4001     0x4002      0x4003
00               00           12              34
则&a的值为0x4000， char占一个字节，即b最终所取的值为0x4000地址内存储的内容，故为0x00。

若处理器为小端 （低地址存储低位） 模式，则b的值为0x34。

//将源字符串加const，表明其为输入参数，加2分
//对源地址和目的地址加非0断言，加3分
//为了实现链式操作，将目的地址返回，加3分！ 
char * strcpy( char *strDest, const char *strSrc ) 
{
 assert( (strDest != NULL) && (strSrc != NULL) );
 char *address = strDest; 
 while( (*strDest++ = * strSrc++) != ‘\0’ ); 
 return address;
}

野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。

写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。另外，当你写下面的代码时会发生什么事？   
least = MIN(* p++, b);  

((*p++) <= (b) ? (* p++) : (b))   
这个表达式会产生副作用，指针p会作2次++自增操作。  

```
编写类String的构造函数、析构函数和赋值函数，已知类String的原型为：
class String
{ 
 public: 
 String(const char *str = NULL); // 普通构造函数 
 String(const String &other); // 拷贝构造函数 
 ~ String(void); // 析构函数 
 String & operator =(const String &other); // 赋值函数 
 private: 
 char *m_data; // 用于保存字符串 
};

//普通构造函数
String::String(const char* str)
{
	if(str==nullptr)//point
	{
		m_data = new char[1];//point:对空字符串自动申请存放结束标志'\0'的空
		*m_data = '\0';
	}
	else
	{
		int length = strlen(str);
		m_data = new char[length + 1];
		strcpy(m_data, str);
	}
}

//String的析构函数
String::~String(void)
{
	delete[] m_data;
}

//拷贝构造函数
String::String(const String &other)//point:输入参数为const
{
	int length = strlen(other.m_data);
	m_data = new char[length+1];
	strcpy(m_data, other.m_data);
}

//复值函数
String & String::operator = (const String &other)//point:输入参数为const
{
	if(this == &other)	//得分点：检查自赋值
		return *this;
	delete[] m_data;	//得分点：释放原有的内存资源
	int length = strlen(other.m_data);
	m_data = new char[length + 1];
	strcpy(m_data, other.m_data);
	return *this;
}

剖析  
在这个类中包括了指针类成员变量m_data，当类中包括指针类成员变量时，一定要重载其拷贝构造函数、赋值函数和析构函数，这既是对C++程序员的基本要求，也是《Effective　C++》中特别强调的条款。 
仔细学习这个类，特别注意加注释的得分点和加分点的意义，这样就具备了60%以上的C++基本功！
```

请说出static和const关键字尽可能多的作用
static关键字至少有下列n个作用：
- 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； 
- 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
- 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
- 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；   
- 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。
const关键字至少有下列n个作用：   
- 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了； 
- 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；   
- 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值； 
- 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；
- 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：   
const classA operator*(const classA& a1,const classA& a2);   
operator * 的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：   
classA a, b, c;   
(a * b) = c; // 对a*b的结果赋值   
操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。   

链接：https://www.nowcoder.com/questionTerminal/9fb652d48bee45bcb47771b2e3c6f690
来源：牛客网

C++告诉我们在回收用 new 分配的单个对象的内存空间的时候用 delete，回收用 new[] 分配的一组对象的内存空间的时候用 delete[]。 
关于 new[] 和 delete[]，其中又分为两种情况：(1) 为基本数据类型分配和回收空间；(2) 为自定义类型分配和回收空间。
基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；但是对于类对象数组，只能用 delete[]。
   所以一个简单的使用原则就是：new 和 delete、new[] 和 delete[] 对应使用。



